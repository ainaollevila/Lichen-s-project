
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>NestednessNTC</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-29"><meta name="DC.source" content="NestednessNTC.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">% NestednessNTC - NTC (Nestedness Temperature Calculator) algorithm</span>
<span class="comment">% This class calculates the nestedness of a matrix using the temperature.</span>
<span class="comment">% The value of nestedness if found by normalizing tempereature N = (100-T)</span>
<span class="comment">% / 100, and have values between 0 and 1, where 1 is perfectly nested and 0\</span>
<span class="comment">% perfectly anti-nested. For information about how this algorithm works you</span>
<span class="comment">% can consult the following papers:</span>
<span class="comment">%</span>
<span class="comment">%     Atmar, Wirt and Patterson, Bruce D. The measure of order and disorder</span>
<span class="comment">%     in the distribution of species in fragmented habitat. Oecologia 1993</span>
<span class="comment">%</span>
<span class="comment">%     Rodriguez-Girones, Miguel A and Santamaria, Luis. A new algorithm to</span>
<span class="comment">%     calculate the nestedness temperature of presence--absence matrices.</span>
<span class="comment">%     Journal of Biogeography 2006</span>
<span class="comment">%</span>
<span class="comment">% NestednessNTC Properties:</span>
<span class="comment">%     T - T emperature</span>
<span class="comment">%     do_geometry - Flag to indicate the calculus of geometry</span>
<span class="comment">%     index_rows - Register of the swaps in Rows.</span>
<span class="comment">%     index_cols - Register of the swaps in Cols.</span>
<span class="comment">%     connectance - Fill of the matrix</span>
<span class="comment">%     trials - Number of random initializations</span>
<span class="comment">%     do_sorting - Sort the matrix before calculating the temperature</span>
<span class="comment">%</span>
<span class="comment">% NestednessNTC Methods:</span>
<span class="comment">%     NestednessNTC - Main Constructor</span>
<span class="comment">%     SetMatrix - Change the adjacency matrix of the algorithm</span>
<span class="comment">%     Print - Print NTC nestedness information</span>
<span class="comment">%     NTC - Calculate the NTC nestedness</span>
<span class="comment">%     PERFECT_NESTED - Return a perfect nested matrix according to the NTC algorithm</span>
<span class="comment">%     FIND_UNEXPECTED_CELLS - Return a matrix that indicates what are the unexpected cells.</span>
<span class="comment">%     GET_ISOCLINE - Get the isocline function</span>
<span class="comment">%</span>
<span class="comment">% See also:</span>
<span class="comment">%    NestednessNODF, Nestedness</span>
<span class="keyword">classdef</span> NestednessNTC &lt; Nestedness

    <span class="keyword">properties</span>(GetAccess = <span class="string">'public'</span>, SetAccess = <span class="string">'protected'</span>)
        T                  = 0;    <span class="comment">% T emperature</span>
        do_geometry        = true; <span class="comment">% Flag to indicate the calculus of geometry</span>
        index_rows         = [];   <span class="comment">% Register of the swaps in Rows.</span>
        index_cols         = [];   <span class="comment">% Register of the swaps in Cols.</span>
        connectance        = 0;    <span class="comment">% Fill of the matrix</span>
        trials             = 5;    <span class="comment">% Number of random initializations</span>
        do_sorting         = true; <span class="comment">% Sort the matrix before calculating the temperature</span>
    <span class="keyword">end</span>

    <span class="keyword">properties</span>(Access = <span class="string">'protected'</span>)
        matrix_minimal     = []; <span class="comment">% The matrix with the smalles temperature (highest nestedness)</span>
        P                  = 0;  <span class="comment">% p parameter of the isocline function that is calculated using the fill of the matrix</span>
        pos_x_matrix       = []; <span class="comment">% X coordinate of each matrix cell in a unit square</span>
        pos_y_matrix       = []; <span class="comment">% Y coordinate of each matrix cell in a unit square</span>
        d_matrix           = []; <span class="comment">% distances with the perfect nestedness line</span>
        diag_matrix        = []; <span class="comment">% Size of the diagonal that cross the matrix element</span>
        u_matrix           = []; <span class="comment">% Unexpectedness Matrix</span>
        calculated_fill    = 0;  <span class="comment">% Calculated fill using the integral of fxp(P,X). Ideally must have the same value than the fill of the matrix.</span>
        X                  = []; <span class="comment">% Vector of X coordinate</span>
        fxp                = []; <span class="comment">% Vector of isocline values in y coordinate</span>
        u_min              = 0;  <span class="comment">% Unexpectedness matrix</span>
        tunsorted          = 0;
        sorting_method     = 2; <span class="comment">%1 for NTC, 2 for Sum Heuristic</span>
        n_row_sorts        = 0;
        n_col_sorts        = 0;
    <span class="keyword">end</span>
    <span class="comment">%DEBUG Properties - Change to parametrize and Debug the algorithm;</span>
    <span class="keyword">properties</span>(Access = <span class="string">'protected'</span>)
        p_max               = 99999;      <span class="comment">% Maximal P value for finding the isoclane.</span>
        p_min               = 0.0005;     <span class="comment">% Minimal p value for finding the isoclane.</span>
        used_area           = 2;          <span class="comment">% Chose a value in 1,2,3</span>
        delta_x             = 0.001;      <span class="comment">% X Increment in order to get the vector of the Isoclane values (obj.fxp)</span>
        debug_messages      = 0;          <span class="comment">% 1,0 Print Debug Messages</span>
        K                  = 2.4125e+003 <span class="comment">% 100 / 0.04145;  %Value found in the literature</span>
        break_random        = 20;         <span class="comment">% How many initial random permutations in the matrix</span>
    <span class="keyword">end</span>

    <span class="comment">%CONSTRUCTOR AND MAIN PROCEDURE ALGORITHM</span>
    <span class="keyword">methods</span>


        <span class="keyword">function</span> obj = NestednessNTC(bipmatrix)
        <span class="comment">% NestednessNTC - Main Constructor</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = NestednessNTC(MATRIX) Creates an NestednessNTC object obj</span>
        <span class="comment">%   using a bipartite adjacency matrix MATRIX that will be used to</span>
        <span class="comment">%   calculate nestedes using the Nestedness Temperature Calculator</span>
        <span class="comment">%   (NTC).</span>
        <span class="comment">%</span>
        <span class="comment">% See also:</span>
        <span class="comment">%    NestednessNODF</span>
            obj = obj@Nestedness(bipmatrix);

            [obj.n_rows, obj.n_cols] = size(obj.matrix);
            obj.connectance = sum(sum(obj.matrix))/(obj.n_rows*obj.n_cols);

            obj.index_rows = 1:obj.n_rows;
            obj.index_cols = 1:obj.n_cols;

        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = SetMatrix(obj,matrix)
        <span class="comment">%   obj = SetMatrix(obj,matrix) Change the matrix in which the</span>
        <span class="comment">%   algorithm will be performed. Useful only when the new matrix</span>
        <span class="comment">%   has the same size and similar connectance (fill) than a</span>
        <span class="comment">%   the old matrix. Using this method, we do not have to perform</span>
        <span class="comment">%   the goemetrical pre-calculus another time (isocline, distances,</span>
        <span class="comment">%   diagonals, etc).</span>
        <span class="comment">%</span>
        <span class="comment">%   Be cautious while changing the matrix. The change of the matrix</span>
        <span class="comment">%   will cause that NestednessNTC will not recalculate the values</span>
        <span class="comment">%   of geometry and distances. Therefore, the matrix must have the</span>
        <span class="comment">%   same size and similar connectance. Otherwise the results will</span>
        <span class="comment">%   be spurious.</span>

            <span class="comment">%Make sure that at least the size of the new matrix is the same</span>
            assert(sum(size(matrix) == size(obj.matrix))==2);

            obj.matrix = matrix &gt; 0; <span class="comment">%Normalize the matrix</span>
            [obj.n_rows, obj.n_cols] = size(matrix);
            obj.connectance = sum(sum(obj.matrix))/numel(obj.matrix);
            obj.index_rows = 1:obj.n_rows;
            obj.index_cols = 1:obj.n_cols;
            obj.do_geometry = 0;

        <span class="keyword">end</span>


        <span class="keyword">function</span> str = Print(obj,filename)
        <span class="comment">% Print - Print NTC nestedness information</span>
        <span class="comment">%</span>
        <span class="comment">%   STR = Print(obj) Print the NTC information to screen and</span>
        <span class="comment">%   return this information to the string STR</span>
        <span class="comment">%</span>
        <span class="comment">%   STR = Print(obj, FILE) Print the NTC information to screen and</span>
        <span class="comment">%   text file FILE and return this information to the string STR</span>
        <span class="comment">%</span>
        <span class="comment">% See also:</span>
        <span class="comment">%   Printer</span>

            str = <span class="string">'Nestedness NTC:\n'</span>;
            str = [str, <span class="string">'\tNTC (Nestedness value):     \t'</span>, sprintf(<span class="string">'%20.4f'</span>,obj.N), <span class="string">'\n'</span>];
            str = [str, <span class="string">'\tT (Temperature value):      \t'</span>, sprintf(<span class="string">'%20.4f'</span>,obj.T), <span class="string">'\n'</span>];

            fprintf(str);

            <span class="keyword">if</span>(nargin==2)
                Printer.PRINT_TO_FILE(str,filename);
            <span class="keyword">end</span>

        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% GEOMETRY DEFINITION SECTION</span>
    <span class="keyword">methods</span>(Access = <span class="string">'protected'</span>)

        <span class="keyword">function</span> obj = RunNestedAlgorithm(obj)
        <span class="comment">% RunNestedAlgorithm - Main method for calculating NTC nestedness</span>
        <span class="comment">% Temperature Calculator</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = RunNestedAlgorithm(obj) Calculates the nestedness of the</span>
        <span class="comment">%   matrix. Use obj.N after calling this method to get the</span>
        <span class="comment">%   nestedness value, and obj.T for getting the temperature value.</span>

            <span class="keyword">if</span>(isempty(obj.matrix))
                obj.N= NaN;
                obj.T = NaN;
                <span class="keyword">return</span>;
            <span class="keyword">end</span>

            <span class="keyword">if</span>(obj.n_rows==1 || obj.n_cols==1)
                obj.N= 0;
                <span class="keyword">return</span>;
            <span class="keyword">end</span>

            obj.n_row_sorts = 1;
            obj.n_col_sorts = 1;

            <span class="comment">% Perfrom the calculus of geometry (isocline, distances, etc)</span>
            <span class="keyword">if</span>(obj.do_geometry)
                obj.CalculateMatrixGeometry();
            <span class="keyword">end</span>

            <span class="comment">%Calculate the temperature</span>
            obj.CalculateTemperature();

            <span class="comment">%Normalize the temperature to the nestedness value</span>
            obj.N= (100-obj.T)/100;

            <span class="comment">%If you want the calculus for a unsorted matrix you are</span>
            <span class="comment">%finished. Normally obj.do_sorting = 1, such that you want an optimal ordering.</span>
            <span class="keyword">if</span>(obj.do_sorting == 0)
                <span class="keyword">return</span>;
            <span class="keyword">end</span>

            <span class="comment">% The next part focus in finding the ordering, such that you</span>
            <span class="comment">% will have the smaller possible value of temperature (and by</span>
            <span class="comment">% consequence the highest nestedness value)</span>

            globalMinimalT = 500;
            matrixLocalMinima = [];
            indexRowLocalMinima = [];
            indexColLocalMinima = [];
            indexRowGlobalMinima = [];
            indexColGlobalMinima = [];


            failedtoincrease = 0; <span class="comment">%Count if the next matrix randomization do an improvement</span>
            <span class="comment">% Do obj.trials initial random permutations of the</span>
            <span class="comment">% matrix to be tested</span>
            <span class="keyword">for</span> i = 1:obj.trials

                <span class="comment">% If no increase is detected in obj.break_random continuos</span>
                <span class="comment">% trials, no need for continue looking.</span>
                <span class="keyword">if</span>(failedtoincrease &gt; obj.break_random)
                    <span class="comment">%fprintf('Break on i = %i\n',i);</span>
                    <span class="keyword">break</span>;
                <span class="keyword">end</span>


                permutationMinimalT = 500; <span class="comment">%temperature infinite</span>
                obj.T = 500;

                [matrix_permuted,new_row_index,new_col_index] = MatrixFunctions.RANDOM_SORT(obj.matrix);
                obj.matrix = matrix_permuted;
                obj.index_rows(new_row_index);
                obj.index_cols(new_col_index);
<span class="comment">%                i = 1;</span>
                <span class="keyword">while</span>(1)
                    <span class="comment">%display(i);</span>
                    <span class="comment">%i = i+1;</span>
                    [sort_matrix, new_row_index, new_col_index] = MatrixFunctions.SORT_MATRIX(obj.matrix);
                    obj.matrix = sort_matrix;
                    obj.index_rows = obj.index_rows(new_row_index);
                    obj.index_cols = obj.index_cols(new_col_index);

                    obj.CalculateTemperature();

                    <span class="keyword">if</span>(obj.debug_messages == 1); fprintf(<span class="string">'TLocal = %f T = %f\n'</span>, permutationMinimalT,obj.T); <span class="keyword">end</span>;

                    <span class="keyword">if</span>(abs(permutationMinimalT - obj.T) &lt;= 0.001 || obj.T &gt; permutationMinimalT)
                        <span class="keyword">break</span>;
                    <span class="keyword">end</span>

                    <span class="keyword">if</span>(obj.T &lt; permutationMinimalT)
                        permutationMinimalT = obj.T;
                        matrixLocalMinima = obj.matrix;
                        indexRowLocalMinima = obj.index_rows;
                        indexColLocalMinima = obj.index_cols;
                    <span class="keyword">end</span>

                <span class="keyword">end</span>
                <span class="keyword">if</span>(obj.debug_messages == 1); fprintf(<span class="string">'finalizo ciclo\n'</span>); <span class="keyword">end</span>;

                <span class="comment">%Save if permutation is smaller than the global minimal</span>
                <span class="keyword">if</span>(permutationMinimalT &lt; globalMinimalT)
                    <span class="comment">%fprintf('TMinimalGlob = %f\n', permutationMinimalT);</span>
                    globalMinimalT = permutationMinimalT;
                    obj.matrix_minimal = matrixLocalMinima;
                    indexRowGlobalMinima = indexRowLocalMinima;
                    indexColGlobalMinima = indexColLocalMinima;
                    failedtoincrease = 0;
                <span class="keyword">end</span>

                failedtoincrease = failedtoincrease + 1;
            <span class="keyword">end</span>

           <span class="comment">%Keep the best sorting for NTC</span>
           obj.matrix = obj.matrix_minimal;
           obj.index_rows = indexRowGlobalMinima;
           obj.index_cols = indexColGlobalMinima;
           obj.T = globalMinimalT;
           obj.N= (100-obj.T)/100;

           obj.done = 1;
           <span class="comment">%obj.PrintOutput();</span>

        <span class="keyword">end</span>


        <span class="keyword">function</span> obj = CalculateMatrixGeometry(obj)
        <span class="comment">% CalculateMatrixGeometry - Calculate all the geometry aspects</span>
        <span class="comment">% of the algorithm</span>
        <span class="comment">%</span>
        <span class="comment">% obj = CalculateMatrixGeometry(obj)</span>
        <span class="comment">% This function calculate all the matrix geometry in the next</span>
        <span class="comment">% order:</span>
        <span class="comment">%   1.- Coordinate representation of of the matrix elements in a unit scuare.</span>
        <span class="comment">%   2.- Function of the isoclane f(x;p) based in the matrix density Fill</span>
        <span class="comment">%   3.- Main diagonal size for all the the matrix elements.</span>
        <span class="comment">%   4.- Distance along the main diagonal of all the matrix</span>
        <span class="comment">%   elements</span>

            <span class="comment">%1.-Coordinate representation of of the matrix elements in a unit scuare.</span>
            obj.AssignMatrixPositions();

            <span class="comment">%2.- Function of the isoclane f(x;p) based in the matrix density Fill</span>
            obj.X = (0.5/obj.n_cols):obj.delta_x:((obj.n_cols-0.5)/obj.n_cols); <span class="comment">%Define the X Vector of the function</span>
            obj.P = obj.FindPValue();
            obj.fxp = 0.5/obj.n_rows + ((obj.n_rows-1)/obj.n_rows) * (1-(1-(obj.n_cols*(obj.X)-0.5)/(obj.n_cols-1)).^(obj.P)).^(1/(obj.P));
            <span class="comment">%3.-,4.-</span>
            obj.CalculateDiagonalsAndDistances();

        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = AssignMatrixPositions(obj)
        <span class="comment">% AssignMatrixPositions - Map the matrix elements to a unit</span>
        <span class="comment">% square coordinate system.</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = AssignMatrixPositiong(obj) - Map the matrix elements to a unit</span>
        <span class="comment">%   square coordinate system.</span>
            <span class="keyword">for</span> i = 1:obj.n_rows
                <span class="keyword">for</span> j = 1:obj.n_cols
                    obj.pos_x_matrix(i,j) = (j-0.5)/obj.n_cols;
                    obj.pos_y_matrix(i,j) = (obj.n_rows-i+0.5)/obj.n_rows;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> p = FindPValue(obj)
            <span class="comment">% FindPValue - Find the parameter 'p' of the isocline function</span>
            <span class="comment">%   p = FindPValue(obj) - Get the parameter p of the isocline</span>
            <span class="comment">%   function by doing a search in the p space and doing a</span>
            <span class="comment">%   bisection method at the end, such that the area above the</span>
            <span class="comment">%   isocline is the same than the connectance (fill) of the matrix.</span>

            p = obj.p_min; <span class="comment">%Starting with the minimal pre-defined value of p parameter</span>
            filledarea = 0; <span class="comment">%Area above the curve. The objective is to equalize to obj.connectance.</span>
            <span class="keyword">while</span>(p &lt; obj.p_max) <span class="comment">%After some predefined p_max the increase in p will not affect the form of the isocline</span>
                filledarea = obj.GetFilledArea(p);
                <span class="keyword">if</span>(obj.connectance &gt; filledarea)
                    <span class="keyword">break</span>;
                <span class="keyword">end</span>
                <span class="keyword">if</span>(obj.debug_messages); fprintf(<span class="string">'area = %5.4f p = %5.4f\n'</span>, filledarea,p); <span class="keyword">end</span>;
                p = p*2;
            <span class="keyword">end</span>

            <span class="comment">%if(obj.debug_messages); fprintf('area = %10.9f p = %5.4f lastp = %5.4f\n', filledarea,upp,lowp); end;</span>

            <span class="keyword">if</span>(p &lt; obj.p_max &amp;&amp; p &gt; obj.p_min) <span class="comment">%If the parameter p is not an extreme case</span>
                <span class="comment">%BISECTION METHOD</span>
                upp = p;
                lowp = p / 2;
                mid = 0;
                <span class="keyword">while</span>( abs( obj.connectance - filledarea) &gt; 0.001)
                    mid = (upp + lowp)/2;
                    filledarea = obj.GetFilledArea(mid);
                    <span class="keyword">if</span>(filledarea &lt; obj.connectance)
                        upp = mid;
                    <span class="keyword">else</span>
                        lowp = mid;
                    <span class="keyword">end</span>
                    <span class="keyword">if</span>(obj.debug_messages); fprintf(<span class="string">'area = %10.9f p = %f\n'</span>, filledarea,mid); <span class="keyword">end</span>;
                <span class="keyword">end</span>
                <span class="keyword">if</span>(mid ~= 0)
                    p = mid;
                <span class="keyword">end</span>;
            <span class="keyword">end</span>

            obj.calculated_fill = filledarea;
        <span class="keyword">end</span>

        <span class="keyword">function</span> Area = GetFilledArea(obj,p)
        <span class="comment">% GetFilledArea - Get the area above the isocline</span>
        <span class="comment">%</span>
        <span class="comment">%   Area = GetFilledArea(obj,p) - Ghet the area above the</span>
        <span class="comment">%   isocline with parameter p.</span>


            <span class="comment">%Isocline equation</span>
            obj.fxp = 0.5/obj.n_rows + ((obj.n_rows-1)/obj.n_rows) * (1-(1-(obj.n_cols*(obj.X)-0.5)/(obj.n_cols-1)).^p).^(1/p);

            <span class="comment">%Area below the isocline</span>
            integral = trapz(obj.X,obj.fxp);

            <span class="comment">%Three ways of calculating the area (only important when the</span>
            <span class="comment">%matrix is small. Case 2 gives the best results.</span>
            <span class="keyword">switch</span> obj.used_area
                <span class="keyword">case</span> 1
                    Area = 1 - real(integral);
                <span class="keyword">case</span> 2
                    Area = 1 - real(integral) - (obj.n_rows-0.5)*(0.5)/(obj.n_rows*obj.n_cols);
                <span class="keyword">otherwise</span>
                    Area = (obj.n_rows-0.5)/(obj.n_rows-1) - real(integral) * obj.n_rows * obj.n_cols / ((obj.n_cols-1)*(obj.n_rows-1));
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = CalculateDiagonalsAndDistances(obj)
        <span class="comment">% CalculateDiagonalsAndDistances - Calculate diagonal and</span>
        <span class="comment">% isocline distance size matrices</span>
        <span class="comment">%</span>
        <span class="comment">%   obj = CalculateDiagonalsAndDistances(obj) - Calculate diagonal and</span>
        <span class="comment">%   isocline distance size matrices</span>
            obj.u_matrix = zeros(size(obj.matrix));
            MaxDiag = sqrt(2);

            obj.diag_matrix = zeros(size(obj.matrix));
            obj.d_matrix = zeros(size(obj.matrix));

            <span class="comment">%For each row and column</span>
            <span class="keyword">for</span> i = 1:obj.n_rows
                <span class="keyword">for</span> j = 1:obj.n_cols

                    y1 = real(obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j) - obj.X);
                    y2 = obj.fxp;

                    [~, index] = min(abs(y1-y2));

                    <span class="comment">%Intersection point between the diagonal and the</span>
                    <span class="comment">%iscoline</span>
                    ycross = y1(index);
                    xcross = obj.X(index);

                    <span class="comment">%Distance from the isocline to the matrix element</span>
                    distance = sqrt( (obj.pos_x_matrix(i,j)-xcross)^2 + (obj.pos_y_matrix(i,j)-ycross)^2 );
                    obj.d_matrix(i,j) = distance;
                    obj.diag_matrix(i,j) = (obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j)) * sqrt(2);

                    <span class="keyword">if</span>(obj.diag_matrix(i,j) &gt; MaxDiag)
                        obj.diag_matrix(i,j) = abs(obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j) - 2) * sqrt(2);
                    <span class="keyword">end</span>

                    <span class="comment">% Change to negative elements below isocline, such that</span>
                    <span class="comment">% the sign will differentiate above vs below isocline</span>
                    <span class="comment">% elemnts.</span>
                    <span class="keyword">if</span>(obj.pos_y_matrix(i,j) &lt; ycross)
                        obj.d_matrix(i,j) = -obj.d_matrix(i,j);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% CALCULATE TEMPERATURE AND IMPORTANT VALUES</span>
    <span class="keyword">methods</span>(Access = <span class="string">'protected'</span>)

        <span class="keyword">function</span> obj = CalculateTemperature(obj)
            <span class="comment">% CalculateTemperature - Calculate the matrix temperature</span>
            <span class="comment">%   obj = CalculateTemperature(obj) - Calculate the temperature</span>
            <span class="comment">%   using the Atmar standard equation. The temperature is in</span>
            <span class="comment">%   the interval [0,100], while the nestedness in the interval</span>
            <span class="comment">%   [0,1]. High values of temperature corresponds to low values</span>
            <span class="comment">%   of nestedness.</span>
            obj.u_min = obj.CalculateUnexpectedness();
            obj.T = obj.K*obj.u_min;
            obj.N= (100-obj.T)/100;
        <span class="keyword">end</span>

        <span class="keyword">function</span> unex = CalculateUnexpectedness(obj)
            <span class="comment">% CalculateUnexpectedness - Calculate the matrix unexpectedness</span>
            <span class="comment">%   obj = CalculateUnexpectedness(obj) - Sum all temperature</span>
            <span class="comment">%   contributions from unexpected cells (absences below the</span>
            <span class="comment">%   matrix and presences above the matrix)</span>
            obj.u_matrix = zeros(size(obj.matrix));
            obj.u_matrix = ((obj.matrix==0 &amp; obj.d_matrix &gt; 0) | (obj.matrix ~=0 &amp; obj.d_matrix &lt; 0 )).*((obj.d_matrix./obj.diag_matrix).^2);
            unex = sum(sum(obj.u_matrix)) / (obj.n_rows*obj.n_cols);
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">methods</span>(Static)

        <span class="keyword">function</span> ntc = NTC(matrix)
        <span class="comment">% NTC - Calculate the NTC nestedness</span>
        <span class="comment">%</span>
        <span class="comment">%   nest = NTC(matrix) Calculate the NTC nestedness,</span>
        <span class="comment">%   print the basic information to</span>
        <span class="comment">%   screen and return an NestednessNTC object that contains such</span>
        <span class="comment">%   information in nest.</span>

            ntc = NestednessNTC(matrix);
            ntc.Detect();
            ntc.Print();
        <span class="keyword">end</span>

        <span class="keyword">function</span> matrix = PERFECT_NESTED(nrows,ncols,fill)
        <span class="comment">% PERFECT_NESTED - Return a perfect nested matrix according to the</span>
        <span class="comment">% NTC algorithm</span>
        <span class="comment">%</span>
        <span class="comment">%   matrix = PERFECT_NESTED(nrows,ncols,fill) - Return a perfect</span>
        <span class="comment">%   nested matrix of size nrows by ncols and a connectance = fill.</span>
        <span class="comment">%   The perfect nested matrix follows the definition of the NTC</span>
        <span class="comment">%   algorithm (the isocline divide ones from zeros in the entire</span>
        <span class="comment">%   matrix).</span>
            matrix = zeros(nrows,ncols);

            bnest = NetworkBipartite(matrix);

            nest = NestednessNTC(bnest);
            nest.Fill = fill;
            nest = nest.CalculateMatrixGeometry();
            nest = nest.CalculateDiagonalsAndDistances();

            <span class="keyword">for</span> i = 1:nrows
                <span class="keyword">for</span> j = 1:ncols
                    <span class="keyword">if</span>(nest.dMatrix(i,j) &gt; 0)
                        matrix(i,j) = 1;
                    <span class="keyword">else</span>
                        matrix(i,j) = 0;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            matrix(nrows,1) = 1;
            matrix(1,ncols) = 1;

        <span class="keyword">end</span>

        <span class="keyword">function</span> matrix_unex = FIND_UNEXPECTED_CELLS(matrix)
        <span class="comment">% FIND_UNEXPECTED_CELLS - Return a matrix that indicate what are the</span>
        <span class="comment">% unexpected cells.</span>
        <span class="comment">%</span>
        <span class="comment">%   matrix = FIND_UNEXPECTED_CELLS(matrix) - For matrix 'matrix',</span>
        <span class="comment">%   calculate the geometry in order to return a matrix 'matrix_unex'</span>
        <span class="comment">%   with ones in the position of unexpected cells of the original</span>
        <span class="comment">%   matrix.</span>
            nest = NestednessNTC(matrix);
            nest.CalculateMatrixGeometry();
            nest.CalculateUnexpectedness();

            matrix_unex = nest.uMatrix &gt; 0;<span class="comment">%.0005;</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> [x,y] = GET_ISOCLINE(n_rows,n_cols,p_value)
        <span class="comment">% GET_ISOCLINE - Get the isocline function</span>
        <span class="comment">%</span>
        <span class="comment">%   [x y] = GET_ISOCLINE(n_rows,n_cols,p_value) - Get the isocline</span>
        <span class="comment">%   function in x and y vectors for a matrix of size n_rows by</span>
        <span class="comment">%   n_cols and a connectance of p_value. Useful when the user is</span>
        <span class="comment">%   only interested in the isocline (e.g. plotting) and not the</span>
        <span class="comment">%   temperature value.</span>
            <span class="keyword">if</span>(nargin==1)
                matrix_loc = n_rows&gt;0;
            <span class="keyword">else</span>
                matrix_loc = zeros(n_rows,n_cols);
                len = n_rows*n_cols;
                matrix_loc(1:round(len*p_value))=1;
            <span class="keyword">end</span>

            ntc = NestednessNTC(matrix_loc);

            ntc.CalculateMatrixGeometry();
            x = 0.5 + ntc.n_cols.*ntc.X;
            y = 0.5 + ntc.n_rows.*ntc.fxp;
        <span class="keyword">end</span>

    <span class="keyword">end</span>


<span class="keyword">end</span>
</pre><pre class="codeoutput error">Error using NestednessNTC (line 89)
Not enough input arguments.
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
% NestednessNTC - NTC (Nestedness Temperature Calculator) algorithm
% This class calculates the nestedness of a matrix using the temperature.
% The value of nestedness if found by normalizing tempereature N = (100-T)
% / 100, and have values between 0 and 1, where 1 is perfectly nested and 0\
% perfectly anti-nested. For information about how this algorithm works you
% can consult the following papers:
%
%     Atmar, Wirt and Patterson, Bruce D. The measure of order and disorder
%     in the distribution of species in fragmented habitat. Oecologia 1993
%
%     Rodriguez-Girones, Miguel A and Santamaria, Luis. A new algorithm to
%     calculate the nestedness temperature of presenceREPLACE_WITH_DASH_DASHabsence matrices.
%     Journal of Biogeography 2006
%
% NestednessNTC Properties:
%     T - T emperature
%     do_geometry - Flag to indicate the calculus of geometry
%     index_rows - Register of the swaps in Rows.
%     index_cols - Register of the swaps in Cols.
%     connectance - Fill of the matrix
%     trials - Number of random initializations
%     do_sorting - Sort the matrix before calculating the temperature
%
% NestednessNTC Methods:
%     NestednessNTC - Main Constructor
%     SetMatrix - Change the adjacency matrix of the algorithm
%     Print - Print NTC nestedness information
%     NTC - Calculate the NTC nestedness
%     PERFECT_NESTED - Return a perfect nested matrix according to the NTC algorithm
%     FIND_UNEXPECTED_CELLS - Return a matrix that indicates what are the unexpected cells.
%     GET_ISOCLINE - Get the isocline function
%
% See also:
%    NestednessNODF, Nestedness
classdef NestednessNTC < Nestedness

    properties(GetAccess = 'public', SetAccess = 'protected')
        T                  = 0;    % T emperature
        do_geometry        = true; % Flag to indicate the calculus of geometry
        index_rows         = [];   % Register of the swaps in Rows.
        index_cols         = [];   % Register of the swaps in Cols.
        connectance        = 0;    % Fill of the matrix
        trials             = 5;    % Number of random initializations
        do_sorting         = true; % Sort the matrix before calculating the temperature
    end
    
    properties(Access = 'protected')
        matrix_minimal     = []; % The matrix with the smalles temperature (highest nestedness)
        P                  = 0;  % p parameter of the isocline function that is calculated using the fill of the matrix
        pos_x_matrix       = []; % X coordinate of each matrix cell in a unit square
        pos_y_matrix       = []; % Y coordinate of each matrix cell in a unit square
        d_matrix           = []; % distances with the perfect nestedness line
        diag_matrix        = []; % Size of the diagonal that cross the matrix element
        u_matrix           = []; % Unexpectedness Matrix
        calculated_fill    = 0;  % Calculated fill using the integral of fxp(P,X). Ideally must have the same value than the fill of the matrix.
        X                  = []; % Vector of X coordinate
        fxp                = []; % Vector of isocline values in y coordinate
        u_min              = 0;  % Unexpectedness matrix
        tunsorted          = 0;  
        sorting_method     = 2; %1 for NTC, 2 for Sum Heuristic
        n_row_sorts        = 0;
        n_col_sorts        = 0;
    end
    %DEBUG Properties - Change to parametrize and Debug the algorithm;
    properties(Access = 'protected')
        p_max               = 99999;      % Maximal P value for finding the isoclane.
        p_min               = 0.0005;     % Minimal p value for finding the isoclane.
        used_area           = 2;          % Chose a value in 1,2,3
        delta_x             = 0.001;      % X Increment in order to get the vector of the Isoclane values (obj.fxp)
        debug_messages      = 0;          % 1,0 Print Debug Messages
        K                  = 2.4125e+003 % 100 / 0.04145;  %Value found in the literature
        break_random        = 20;         % How many initial random permutations in the matrix
    end
    
    %CONSTRUCTOR AND MAIN PROCEDURE ALGORITHM
    methods

        
        function obj = NestednessNTC(bipmatrix)
        % NestednessNTC - Main Constructor
        % 
        %   obj = NestednessNTC(MATRIX) Creates an NestednessNTC object obj
        %   using a bipartite adjacency matrix MATRIX that will be used to
        %   calculate nestedes using the Nestedness Temperature Calculator
        %   (NTC).
        %
        % See also:
        %    NestednessNODF
            obj = obj@Nestedness(bipmatrix);
            
            [obj.n_rows, obj.n_cols] = size(obj.matrix);
            obj.connectance = sum(sum(obj.matrix))/(obj.n_rows*obj.n_cols);   
                        
            obj.index_rows = 1:obj.n_rows;
            obj.index_cols = 1:obj.n_cols;
            
        end

        function obj = SetMatrix(obj,matrix)
        %   obj = SetMatrix(obj,matrix) Change the matrix in which the
        %   algorithm will be performed. Useful only when the new matrix
        %   has the same size and similar connectance (fill) than a
        %   the old matrix. Using this method, we do not have to perform
        %   the goemetrical pre-calculus another time (isocline, distances,
        %   diagonals, etc).
        %   
        %   Be cautious while changing the matrix. The change of the matrix
        %   will cause that NestednessNTC will not recalculate the values
        %   of geometry and distances. Therefore, the matrix must have the
        %   same size and similar connectance. Otherwise the results will
        %   be spurious.
            
            %Make sure that at least the size of the new matrix is the same
            assert(sum(size(matrix) == size(obj.matrix))==2);
            
            obj.matrix = matrix > 0; %Normalize the matrix
            [obj.n_rows, obj.n_cols] = size(matrix);
            obj.connectance = sum(sum(obj.matrix))/numel(obj.matrix);
            obj.index_rows = 1:obj.n_rows;
            obj.index_cols = 1:obj.n_cols;
            obj.do_geometry = 0;

        end

        
        function str = Print(obj,filename)
        % Print - Print NTC nestedness information
        %
        %   STR = Print(obj) Print the NTC information to screen and
        %   return this information to the string STR
        %
        %   STR = Print(obj, FILE) Print the NTC information to screen and
        %   text file FILE and return this information to the string STR   
        %
        % See also: 
        %   Printer
            
            str = 'Nestedness NTC:\n';
            str = [str, '\tNTC (Nestedness value):     \t', sprintf('%20.4f',obj.N), '\n'];
            str = [str, '\tT (Temperature value):      \t', sprintf('%20.4f',obj.T), '\n'];
           
            fprintf(str);  
            
            if(nargin==2)
                Printer.PRINT_TO_FILE(str,filename);
            end
            
        end
           
    end

    % GEOMETRY DEFINITION SECTION
    methods(Access = 'protected')
       
        function obj = RunNestedAlgorithm(obj)
        % RunNestedAlgorithm - Main method for calculating NTC nestedness
        % Temperature Calculator
        %
        %   obj = RunNestedAlgorithm(obj) Calculates the nestedness of the
        %   matrix. Use obj.N after calling this method to get the
        %   nestedness value, and obj.T for getting the temperature value.
        
            if(isempty(obj.matrix))
                obj.N= NaN;
                obj.T = NaN;
                return;
            end
        
            if(obj.n_rows==1 || obj.n_cols==1)
                obj.N= 0;
                return;
            end
            
            obj.n_row_sorts = 1;
            obj.n_col_sorts = 1;
            
            % Perfrom the calculus of geometry (isocline, distances, etc)
            if(obj.do_geometry)
                obj.CalculateMatrixGeometry();
            end

            %Calculate the temperature
            obj.CalculateTemperature();

            %Normalize the temperature to the nestedness value
            obj.N= (100-obj.T)/100;
            
            %If you want the calculus for a unsorted matrix you are
            %finished. Normally obj.do_sorting = 1, such that you want an optimal ordering. 
            if(obj.do_sorting == 0)
                return;
            end
                        
            % The next part focus in finding the ordering, such that you
            % will have the smaller possible value of temperature (and by
            % consequence the highest nestedness value)
            
            globalMinimalT = 500;
            matrixLocalMinima = [];
            indexRowLocalMinima = [];
            indexColLocalMinima = [];
            indexRowGlobalMinima = [];
            indexColGlobalMinima = [];
            
            
            failedtoincrease = 0; %Count if the next matrix randomization do an improvement
            % Do obj.trials initial random permutations of the
            % matrix to be tested
            for i = 1:obj.trials
                
                % If no increase is detected in obj.break_random continuos
                % trials, no need for continue looking.
                if(failedtoincrease > obj.break_random)
                    %fprintf('Break on i = %i\n',i);
                    break;
                end
                
                
                permutationMinimalT = 500; %temperature infinite
                obj.T = 500;
                
                [matrix_permuted,new_row_index,new_col_index] = MatrixFunctions.RANDOM_SORT(obj.matrix);
                obj.matrix = matrix_permuted;
                obj.index_rows(new_row_index);
                obj.index_cols(new_col_index);
%                i = 1;
                while(1)
                    %display(i);
                    %i = i+1;
                    [sort_matrix, new_row_index, new_col_index] = MatrixFunctions.SORT_MATRIX(obj.matrix);
                    obj.matrix = sort_matrix;
                    obj.index_rows = obj.index_rows(new_row_index);
                    obj.index_cols = obj.index_cols(new_col_index);
                    
                    obj.CalculateTemperature();
                    
                    if(obj.debug_messages == 1); fprintf('TLocal = %f T = %f\n', permutationMinimalT,obj.T); end;
                    
                    if(abs(permutationMinimalT - obj.T) <= 0.001 || obj.T > permutationMinimalT)
                        break;
                    end
                        
                    if(obj.T < permutationMinimalT)
                        permutationMinimalT = obj.T;
                        matrixLocalMinima = obj.matrix;
                        indexRowLocalMinima = obj.index_rows;
                        indexColLocalMinima = obj.index_cols;
                    end
                    
                end
                if(obj.debug_messages == 1); fprintf('finalizo ciclo\n'); end;
                
                %Save if permutation is smaller than the global minimal
                if(permutationMinimalT < globalMinimalT)
                    %fprintf('TMinimalGlob = %f\n', permutationMinimalT);
                    globalMinimalT = permutationMinimalT;
                    obj.matrix_minimal = matrixLocalMinima;
                    indexRowGlobalMinima = indexRowLocalMinima;
                    indexColGlobalMinima = indexColLocalMinima;
                    failedtoincrease = 0;
                end
                
                failedtoincrease = failedtoincrease + 1;
            end
            
           %Keep the best sorting for NTC
           obj.matrix = obj.matrix_minimal;
           obj.index_rows = indexRowGlobalMinima;
           obj.index_cols = indexColGlobalMinima;
           obj.T = globalMinimalT;
           obj.N= (100-obj.T)/100;
            
           obj.done = 1;
           %obj.PrintOutput();
            
        end

        
        function obj = CalculateMatrixGeometry(obj)
        % CalculateMatrixGeometry - Calculate all the geometry aspects
        % of the algorithm
        %
        % obj = CalculateMatrixGeometry(obj)
        % This function calculate all the matrix geometry in the next
        % order:
        %   1.- Coordinate representation of of the matrix elements in a unit scuare.
        %   2.- Function of the isoclane f(x;p) based in the matrix density Fill
        %   3.- Main diagonal size for all the the matrix elements.
        %   4.- Distance along the main diagonal of all the matrix
        %   elements 
         
            %1.-Coordinate representation of of the matrix elements in a unit scuare.
            obj.AssignMatrixPositions();
            
            %2.- Function of the isoclane f(x;p) based in the matrix density Fill
            obj.X = (0.5/obj.n_cols):obj.delta_x:((obj.n_cols-0.5)/obj.n_cols); %Define the X Vector of the function
            obj.P = obj.FindPValue();
            obj.fxp = 0.5/obj.n_rows + ((obj.n_rows-1)/obj.n_rows) * (1-(1-(obj.n_cols*(obj.X)-0.5)/(obj.n_cols-1)).^(obj.P)).^(1/(obj.P));
            %3.-,4.-
            obj.CalculateDiagonalsAndDistances();
            
        end
        
        function obj = AssignMatrixPositions(obj)
        % AssignMatrixPositions - Map the matrix elements to a unit
        % square coordinate system.
        %
        %   obj = AssignMatrixPositiong(obj) - Map the matrix elements to a unit
        %   square coordinate system.
            for i = 1:obj.n_rows
                for j = 1:obj.n_cols
                    obj.pos_x_matrix(i,j) = (j-0.5)/obj.n_cols;
                    obj.pos_y_matrix(i,j) = (obj.n_rows-i+0.5)/obj.n_rows;
                end 
            end
        end
        
        function p = FindPValue(obj)
            % FindPValue - Find the parameter 'p' of the isocline function
            %   p = FindPValue(obj) - Get the parameter p of the isocline
            %   function by doing a search in the p space and doing a
            %   bisection method at the end, such that the area above the
            %   isocline is the same than the connectance (fill) of the matrix.
            
            p = obj.p_min; %Starting with the minimal pre-defined value of p parameter
            filledarea = 0; %Area above the curve. The objective is to equalize to obj.connectance.
            while(p < obj.p_max) %After some predefined p_max the increase in p will not affect the form of the isocline
                filledarea = obj.GetFilledArea(p);
                if(obj.connectance > filledarea) 
                    break;
                end
                if(obj.debug_messages); fprintf('area = %5.4f p = %5.4f\n', filledarea,p); end; 
                p = p*2;          
            end
            
            %if(obj.debug_messages); fprintf('area = %10.9f p = %5.4f lastp = %5.4f\n', filledarea,upp,lowp); end;
            
            if(p < obj.p_max && p > obj.p_min) %If the parameter p is not an extreme case
                %BISECTION METHOD
                upp = p;
                lowp = p / 2;
                mid = 0;
                while( abs( obj.connectance - filledarea) > 0.001)
                    mid = (upp + lowp)/2;
                    filledarea = obj.GetFilledArea(mid);
                    if(filledarea < obj.connectance)
                        upp = mid;
                    else
                        lowp = mid;
                    end
                    if(obj.debug_messages); fprintf('area = %10.9f p = %f\n', filledarea,mid); end;        
                end
                if(mid ~= 0)
                    p = mid;
                end;
            end
            
            obj.calculated_fill = filledarea;
        end
        
        function Area = GetFilledArea(obj,p)
        % GetFilledArea - Get the area above the isocline
        %
        %   Area = GetFilledArea(obj,p) - Ghet the area above the
        %   isocline with parameter p.
            
            
            %Isocline equation
            obj.fxp = 0.5/obj.n_rows + ((obj.n_rows-1)/obj.n_rows) * (1-(1-(obj.n_cols*(obj.X)-0.5)/(obj.n_cols-1)).^p).^(1/p);
            
            %Area below the isocline
            integral = trapz(obj.X,obj.fxp);
            
            %Three ways of calculating the area (only important when the
            %matrix is small. Case 2 gives the best results.
            switch obj.used_area
                case 1
                    Area = 1 - real(integral);
                case 2
                    Area = 1 - real(integral) - (obj.n_rows-0.5)*(0.5)/(obj.n_rows*obj.n_cols);
                otherwise
                    Area = (obj.n_rows-0.5)/(obj.n_rows-1) - real(integral) * obj.n_rows * obj.n_cols / ((obj.n_cols-1)*(obj.n_rows-1));
            end
        end
        
        function obj = CalculateDiagonalsAndDistances(obj)
        % CalculateDiagonalsAndDistances - Calculate diagonal and
        % isocline distance size matrices
        %
        %   obj = CalculateDiagonalsAndDistances(obj) - Calculate diagonal and
        %   isocline distance size matrices
            obj.u_matrix = zeros(size(obj.matrix));
            MaxDiag = sqrt(2);
            
            obj.diag_matrix = zeros(size(obj.matrix));
            obj.d_matrix = zeros(size(obj.matrix));
            
            %For each row and column
            for i = 1:obj.n_rows
                for j = 1:obj.n_cols
                         
                    y1 = real(obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j) - obj.X);
                    y2 = obj.fxp;
                    
                    [~, index] = min(abs(y1-y2));
                    
                    %Intersection point between the diagonal and the
                    %iscoline
                    ycross = y1(index);
                    xcross = obj.X(index);

                    %Distance from the isocline to the matrix element
                    distance = sqrt( (obj.pos_x_matrix(i,j)-xcross)^2 + (obj.pos_y_matrix(i,j)-ycross)^2 );
                    obj.d_matrix(i,j) = distance;
                    obj.diag_matrix(i,j) = (obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j)) * sqrt(2);

                    if(obj.diag_matrix(i,j) > MaxDiag)
                        obj.diag_matrix(i,j) = abs(obj.pos_x_matrix(i,j) + obj.pos_y_matrix(i,j) - 2) * sqrt(2);
                    end
                    
                    % Change to negative elements below isocline, such that
                    % the sign will differentiate above vs below isocline
                    % elemnts.
                    if(obj.pos_y_matrix(i,j) < ycross)
                        obj.d_matrix(i,j) = -obj.d_matrix(i,j);
                    end
                end
            end       
        end 
        
    end
    
    % CALCULATE TEMPERATURE AND IMPORTANT VALUES
    methods(Access = 'protected')
        
        function obj = CalculateTemperature(obj)
            % CalculateTemperature - Calculate the matrix temperature
            %   obj = CalculateTemperature(obj) - Calculate the temperature
            %   using the Atmar standard equation. The temperature is in
            %   the interval [0,100], while the nestedness in the interval
            %   [0,1]. High values of temperature corresponds to low values
            %   of nestedness.
            obj.u_min = obj.CalculateUnexpectedness();
            obj.T = obj.K*obj.u_min;
            obj.N= (100-obj.T)/100;
        end
        
        function unex = CalculateUnexpectedness(obj)
            % CalculateUnexpectedness - Calculate the matrix unexpectedness
            %   obj = CalculateUnexpectedness(obj) - Sum all temperature
            %   contributions from unexpected cells (absences below the
            %   matrix and presences above the matrix)
            obj.u_matrix = zeros(size(obj.matrix));
            obj.u_matrix = ((obj.matrix==0 & obj.d_matrix > 0) | (obj.matrix ~=0 & obj.d_matrix < 0 )).*((obj.d_matrix./obj.diag_matrix).^2);   
            unex = sum(sum(obj.u_matrix)) / (obj.n_rows*obj.n_cols);
        end
    end
    
    
    methods(Static)
        
        function ntc = NTC(matrix)
        % NTC - Calculate the NTC nestedness
        %
        %   nest = NTC(matrix) Calculate the NTC nestedness,
        %   print the basic information to
        %   screen and return an NestednessNTC object that contains such
        %   information in nest.
        
            ntc = NestednessNTC(matrix);
            ntc.Detect();
            ntc.Print();
        end
        
        function matrix = PERFECT_NESTED(nrows,ncols,fill)
        % PERFECT_NESTED - Return a perfect nested matrix according to the
        % NTC algorithm
        %
        %   matrix = PERFECT_NESTED(nrows,ncols,fill) - Return a perfect
        %   nested matrix of size nrows by ncols and a connectance = fill.
        %   The perfect nested matrix follows the definition of the NTC
        %   algorithm (the isocline divide ones from zeros in the entire
        %   matrix).
            matrix = zeros(nrows,ncols);
        
            bnest = NetworkBipartite(matrix);
            
            nest = NestednessNTC(bnest);
            nest.Fill = fill;
            nest = nest.CalculateMatrixGeometry();
            nest = nest.CalculateDiagonalsAndDistances();
            
            for i = 1:nrows
                for j = 1:ncols
                    if(nest.dMatrix(i,j) > 0)
                        matrix(i,j) = 1;
                    else
                        matrix(i,j) = 0;
                    end
                end
            end
            
            matrix(nrows,1) = 1;
            matrix(1,ncols) = 1;
           
        end
        
        function matrix_unex = FIND_UNEXPECTED_CELLS(matrix)
        % FIND_UNEXPECTED_CELLS - Return a matrix that indicate what are the
        % unexpected cells.
        %
        %   matrix = FIND_UNEXPECTED_CELLS(matrix) - For matrix 'matrix',
        %   calculate the geometry in order to return a matrix 'matrix_unex'
        %   with ones in the position of unexpected cells of the original
        %   matrix.
            nest = NestednessNTC(matrix);
            nest.CalculateMatrixGeometry();
            nest.CalculateUnexpectedness();
            
            matrix_unex = nest.uMatrix > 0;%.0005;
            
        end
        
        function [x,y] = GET_ISOCLINE(n_rows,n_cols,p_value)
        % GET_ISOCLINE - Get the isocline function
        %
        %   [x y] = GET_ISOCLINE(n_rows,n_cols,p_value) - Get the isocline
        %   function in x and y vectors for a matrix of size n_rows by
        %   n_cols and a connectance of p_value. Useful when the user is
        %   only interested in the isocline (e.g. plotting) and not the
        %   temperature value.
            if(nargin==1)
                matrix_loc = n_rows>0;
            else
                matrix_loc = zeros(n_rows,n_cols);
                len = n_rows*n_cols;
                matrix_loc(1:round(len*p_value))=1;
            end
            
            ntc = NestednessNTC(matrix_loc);
            
            ntc.CalculateMatrixGeometry();
            x = 0.5 + ntc.n_cols.*ntc.X;
            y = 0.5 + ntc.n_rows.*ntc.fxp;
        end
        
    end
    

end

##### SOURCE END #####
--></body></html>